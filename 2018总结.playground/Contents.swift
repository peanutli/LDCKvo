import Cocoa

var str = "Hello, playground"

/*
 struct SideTable {
 // 保证原子操作的自旋锁
 spinlock_t slock;
 // 引用计数的 hash 表
 RefcountMap refcnts;
 // weak 引用全局 hash 表
 weak_table_t weak_table;
 }
 */

/**
 1.分类和扩展有什么区别？可以分别用来做什么？分类有哪些局限性？分类的结构体里面有哪些成员？
    解析：这个问题基本都知道，平时项目里也都遇到过，不好答的地方是，怎么组织语言，在简短的五六分钟内说全面。
    答案：暂不给出答案
 
 2.讲一下atomic的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）？
    解析：atomic 原子属性，实现机制 应该就是 对属性读写操作的时候加同步锁了，为什么又不是绝对的线程安全呢？锁的问题么？
    线程安全：多个线程同时工作的时候，通过某种方式来保证某块内存中的数据的读写不发生错误或冲突。
    答案：属性的atomic是通过自旋锁实现的。但是锁是加到setter 和 getter 方法里面的。只是保证了setter 和 getter 方法的原子性，仅仅是setter 和 getter 放发的原子性。
 
 3.被weak修饰的对象在被释放的时候会发生什么？是如何实现的？知道sideTable么？里面的结构可以画出来么？
    解析:2019网上盛传的手写weak关键字的实现么。 weak 修饰的对象 释放的时候，运行时系统能够将这个对象自动设置成nil,
        置nil这个操作是怎么实现的呢？ 应该是释放的时候，做了操作，感觉sideTable就是一个hash表。
    答案：暂时不给出
 
 4.关联对象有什么应用，系统如何管理关联对象？其被释放的时候需要手动将所有的关联对象的指针置空么？
    解析：这个关联对象说的是 runtime里面 给类添加属性，get 和 set 。 这个用处就是，比如一个已经初始化好的对象，可以通过这个方法，把属性添加上，毕竟一个初始化好的对象的size是已经固定。 被释放的时候，需不需手动将指针置空？这个是个好问题， 我觉得不需要，理由就是只有weak关键字的，会自动置空，其他的也没有做这个处理。
    答案：暂时不给出
 
 5.KVO的底层实现？如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？
    解析:这个我还真自己写了一个。 kvo其实就是一个观察者模式， 我们调用kvo里面添加观察者的方法，监听某一个属性的时候，setter赋值的时候，赋值前和负债后的变化，我们能截取到 。苹果的是现实，穿件了一个新类，然后在setter和getter方法里面添加了两个方法。
        要是取消默认的kvo，苹果提供了一个返回bool值的关闭默认的方法
        改变的值符合某个条件的时候在触发，比如 > 0 的时候，再出发，> 0 再出发的代码，我们需要自己加进去。  这个地方可就
        需要自己手动实现kvo了，在变化方法的地方添加判断条件。
    答案：跟解析差不多。
 
 6.Autoreleasepool所使用的数据结构是什么？AutoreleasePoolPage结构体了解么？
    解析：这个还真了解，之前看过好长时间。让老衲好好回忆下。
    答案：有点头疼
 
 
 7.怎么保证公钥不被篡改呢?
    公钥 --- 客户端  篡改公钥有什么意义呢 跟没有公钥没啥区别   放在数字证书里，其实也挺没意义的。
    公钥加解密 计算量太大  对话 session 对称加密  对称加密的秘钥---  
 */
